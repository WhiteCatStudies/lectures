#pragma once

#include <iostream>


class B
{
public:
	B()
	{
		std::cout << "Default constructor of B\n"; 
	}

	B(int val)
	{
		std::cout << "Constructor of B: Inisializing _bMember with " << val 
			<< "\n";
		_bMemeber = val;
	}

	~B()
	{
		std::cout << "Destructor of B\n";	
	}

private:
	int _bMemeber = 0;
};


class A
{
public:
	// Конструктор с "интуитивной инициализацией" 
	/*A(int bVal)
	{
		// Сначала объект _b класса B будет создан конструктором по умолчанию 
		
		std::cout << "Constructor of A\n";

		// Потом здесь будет создан ещё одни объект B 
		// и будет вызван конструктор B с параметром - B(bVal)
		// Далее копирующее присваиваение _b = B(bVal), в результате которого
		// созданный объект класса B "удвоится".
		// При выходе из данного конструктора объект B, 
		// стоявший в правой части равенства, тоже выходит из области видимости -
		// будет вызов его деструктора. 
		// Объект _b из правой части равенства будет существовать,
		// пока существует данный объект A

		_b = B(bVal);
	}*/

	// Конструктор с списком инициализации
	A(int bVal):
		_b(bVal)
	{
		// Объект _b инициализируется напрямую кoнструктором B(int val)
		// без предварительной инициализации конструктором по умолчанию
		// создания дополнительного объекта B, его копирования 
		// и деинициализации "лишней" копии не происходит
		// Потом данным конструктором будет инициализирован
		// объект класса A 
		// Объект _b точно так же существует до тех пор, 
		// пока существует данный объект A 
		std::cout << "Constructor of A with initialization list\n"; 
	}

	~A()
	{
		// После деструктора A будет вызван деструктор класса B
		std::cout << "Destructor of A\n";
	}


private:
	B _b;
};
